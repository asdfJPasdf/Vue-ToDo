<template >
<!--<div :class="{isDarkmode:darkmode}">-->
  <!-- <createTL :newCategory="newCategory" :categories="categories" /> 
  <boxTL v-for="category in categories" 
    :id="category.id" 
    :categoryName="category.name" 
    :tasks="category.tasks" 
    :key="category.id"
    :newTask="newTask"
  /> -->
  <!--new TL-->
<h1>Vue-ToDo</h1>
<div style="position:absolute; top:0px; right:0px;" >
       <input type="text" placeholder="Search Categorie..." class="form-control-sm" v-model="searchTerm" >
        <!--<button button class="btn btn-dark" @click="searchTask">search</button> -->
        <br> 
    </div> 

   <div class= "d-flex justify-content-center" style="position:absolute top:5px" >
     <center>        <input type="text" placeholder="Add new Tasklist" class="form-control-sm" v-model="newCategory"  @keyup.enter="submitCategories">
        <button button class="btn btn-dark" @click="submitCategories">create Tasklist</button> 
        <br>
        </center>

    </div> 
    
    <!--<button button class="btn btn-dark" @click="darkmode = !darkmode">{{darkmode ? "Lightmode" : "Darkmode"}}</button> -->

  <!-- BoxTL component / assign Parameters-->    
  


 <div  v-if="filtered_Categorie.length">
    <boxTL v-for="categorie in filtered_Categorie "  :key="categorie.id"
    :id="categorie.id"
    :newCategory="newCategory" 
    :categoryName="categorie.categoryName" 
    :tasks="tasks" 
    @submitTask="submitTask"  
    @removeTask="removeTask"
    v-model="categorie.newTask"
    @taskStatus="taskStatus"
    @deleteCategorie="deleteCategorie"
    @update:modelValue="categorie.newCategory = $event"/>
  </div>
   <p v-else class="mt-2">
			It doesn't exist a categorie with this name
		</p>


  
</template>




<script>
import boxTL from "../components/boxTL.vue";
import axios from "axios";


/*import createTL from './components/createTL.vue'*/

export default {
  name: "App",
  components: {
    boxTL /*createTL*/,
  },
  data() {
    return {
      newTask: "",
      categories: [],
      tasks:[],
      newCategory: "",  
      newTL:"",
      searchTerm: "",
     // darkmode: false


        //nicht verwendet
     // NameCategory: "test",
     // categoryName: "Hallo",
     // todo:"",
      
                  


    };
  },
   async created() {
    try {
      const resCategories = await axios.get(`http://localhost:3000/categories`);
      this.categories = resCategories.data;
    } catch (error) {
      console.log(error);
    }
    
    try {
      const resTasks = await axios.get(`http://localhost:3000/tasks`);
      this.tasks = resTasks.data;
    } catch (error) {
      console.log(error);
    }
  },

  
  methods: {

  //Save new Task in Tasks Array 
 async submitTask(id) {
    let new_id;
    
    const index = this.categories.findIndex(item => item.id === id);

    
    console.log(this.newTask);
    if(this.categories[index].newTask =="")
    {
    this.$toast.show(`You cannot add an empty trask!`,{
        type:"error",
        position:'top-right',
        duration:3000,

      });
      return 

}
   if(this.categories.lenght==0){
        new_id=1;
        }
   else if (this.categories.lenght>0) { new_id = this.categories.slice(-1)[0].id + 1;}
      const res = await axios.post(`http://localhost:3000/tasks`, {
        id: new_id,
        taskName: this.categories[index].newTask ,
        categoryId: id,
        status: false
      });
      this.categories[index].newTask = "";
      this.tasks = [...this.tasks, res.data];
      


     /*  
      this.tasklists.push({
        id: new_id,
        name: this.newTask,
        */
     },



   async submitCategories() { 
      
    if(this.newCategory==="") {
      this.$toast.show(`You must give the category a name!`,{
        type:"error",
        position:'top-right',
        duration:3000,

      });
    
     
    }
    else{
   let new_id; 
    if(this.categories.lenght==0){
        new_id=1;
        }
   else if (this.categories.lenght>0) { new_id = this.categories.slice(-1)[0].id + 1;}
    
      const res = await axios.post(`http://localhost:3000/categories`, {
        id: new_id,
        categoryName: this.newCategory,
        newTask: ""
      });
       
      this.categories = [...this.categories, res.data];

      this.newCategory="";
      
    }
     },

    //  async deleteChecklist(id){
    //    //const id = id;
    //    console.log(id);
    //   const res =  await axios.delete(`http://localhost:3000/categories/${id}`);
          
    //       categories: res.categories

    //  }}
       async taskStatus(id) {
    

  try {
    if(this.tasks.find(element =>element.id =id).status){ 
        await axios.patch(`${`http://localhost:3000/tasks`}/${id}`, {
            status: false
        });
        this.tasks = this.tasks.map(task => {
            if (task.id === id) {
                task.status = false;
            }
            return task;
        });
    }
    else{
        await axios.patch(`${`http://localhost:3000/tasks`}/${id}`, {
            status: true
        });
        this.tasks = this.tasks.map(task => {
            if (task.id === id) {
                task.status = true;
            }
            return task;
        });
    } 
    
  }
    catch (error) {
        console.error(error);
    }
    
},


   // removeTask(id) {
    // axios.delete(`http://localhost:3000/tasklists/${id}`)
    // this.tasks = this.tasks.filter(tasks => tasks.id !== id)
    
    /*
 async createTL() {
    if(this.newTL=="") return;
    let new_id_box = this.tasklists.slice(-1)[0].id + 1;
   //  console.log(this.newTask);
     const res = await axios.post(`http://localhost:3000/categories`, {
        id: new_id_box,
        categoryName: this.newTL
      });
      this.tasklists = [...this.tasklists, res.data];
      this.newTL = "";
   },*/
   async removeTask(id){
   axios.delete(`http://localhost:3000/tasks/${id}`);
    this.tasks = this.tasks.filter(tasks => tasks.id !== id);
    
   },
   async deleteCategorie(id){
   axios.delete(`http://localhost:3000/categorie/${id}`);
    this.categories = this.categories.filter(categories => categories.id !== id);
    
   }

      
      

  },
 computed: {
  filtered_Categorie() {

			if (this.searchTerm) {

				return this.categories.filter(categorie => {
					
					
					return this.searchTerm
							.toLowerCase()
							.split(' ')
							.every(word => {
								return 	categorie.categoryName.toLowerCase().includes(word)
										
							});
				});
       

			}
		else {
				return this.categories
			}
		},
  }

  

  
}


</script> 

<style>


.isDarkmode * {
  background-color: rgb(42, 42, 42);
    color: white;
    
}
tbody *{
  text-align: left;
}
.isChecked{ 
  text-decoration: line-through
}
</style>
